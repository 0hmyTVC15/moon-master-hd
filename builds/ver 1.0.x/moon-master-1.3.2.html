<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Moon Master (1.0.02)</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;display:grid;place-items:center;
    font-family:ui-monospace,Menlo,Consolas,monospace}
  #wrap{position:relative}
  canvas{width:768px;height:576px;image-rendering:pixelated;border:4px solid #fff;border-radius:8px;
    box-shadow:0 20px 60px rgba(0,0,0,.8)}
  .bar{position:absolute;top:6px;right:8px;display:flex;gap:8px}
  button{background:#111;border:1px solid #333;color:#ddd;padding:6px 10px;border-radius:6px;cursor:pointer}
  #hint{position:absolute;left:8px;right:8px;bottom:6px;font-size:12px;opacity:.75;display:flex;justify-content:space-between}

  body{background:#000000;}

  canvas{display:block;margin:0 auto;}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c" width="256" height="192"></canvas>
  <div class="bar">
    <button id="reset">Reset</button>
    <button id="full">Fullscreen</button>
  </div>
  <div id="hint"><div>← → = move | ↑ = jump | x/space = zap</div><div>Not affiliated with Adult Swim</div></div>
</div>
<script>
(() => {
  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d', {alpha:false});
  const W=cvs.width, H=cvs.height;
  const GROUND_Y = H-20;
  ctx.imageSmoothingEnabled = false;

  const COL = { BG:'#000000', INK:'#ffffff', G1:'#00ff66', G2:'#ff00aa', G3:'#00e7ff', Y:'#ffff55' };

const ENEMY_PALETTE = ['#ff00aa','#00e7ff','#ffd400','#66ff66','#ff5555','#55aaff','#aa66ff','#ffaa33'];
  function getLevelColor(){
    try { return ENEMY_PALETTE[(Math.max(1, (typeof level!=='undefined'? level : 1))-1) % ENEMY_PALETTE.length]; }
    catch(_) { return ENEMY_PALETTE[0]; }
  }


// --- Gorgatron sprite (embedded) ---
const GORG_IMG_SRC = 'data:image/png;base64,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AAAQ6AAAAIBABwAAAIEOAAAACHQAAAAQ6AAAAIBABwAAAIEOAAAACHQAAAAQ6AAAAIBABwAAAIEOAAAACHQAAAAQ6AAAAIBABwAAAIEOAAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAAAQ6AAAACHQAAABAoAMAAIBABwAAABYRUjyosa9LpwYAAIAtsUEHAAAAgQ4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGToJ1afldRhUxaxAAAAAElFTkSuQmCC';
const GORG_IMG = new Image();
GORG_IMG.src = GORG_IMG_SRC;
let GORG_READY = false;
GORG_IMG.onload = ()=>{ GORG_READY = true; };
// --- end sprite ---


// --- color helpers for cube shading ---
function hexToRgb(hex){
  const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : { r:255,g:255,b:255 };
}
function shadeColor(hex, pct){
  // pct in [-1, +1]; negative = darker, positive = lighter
  const c = hexToRgb(hex);
  const t = pct < 0 ? 0 : 255;
  const p = Math.abs(pct);
  const r = Math.round((t - c.r) * p + c.r);
  const g = Math.round((t - c.g) * p + c.g);
  const b = Math.round((t - c.b) * p + c.b);
  return `rgb(${r},${g},${b})`;
}
// --- end helpers ---


  

// --- minimal WebAudio SFX ---
let __actx=null, __master=null;
function __ensureAudio(){
  if (__actx) return;
  const AC = window.AudioContext || window.webkitAudioContext;
  if (!AC) return;
  __actx = new AC();
  __master = __actx.createGain();
  __master.gain.value = 0.15;
  __master.connect(__actx.destination);
}
function __beep(freq=440, dur=0.08, type='square', vol=0.25){
  if (!__actx) __ensureAudio();
  if (!__actx) return;
  const o = __actx.createOscillator();
  const g = __actx.createGain();
  o.type = type; o.frequency.setValueAtTime(freq, __actx.currentTime);
  o.connect(g); g.connect(__master);
  const t = __actx.currentTime;
  g.gain.setValueAtTime(0, t);
  g.gain.linearRampToValueAtTime(vol, t+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
  o.start(t); o.stop(t+dur+0.02);
}
function sfx(name){
  try{
    __ensureAudio();
    switch(name){
      case 'shoot': __beep(760,0.05,'square',0.18); break;
      case 'hit':   __beep(280,0.08,'square',0.22); __beep(180,0.10,'square',0.18); break;
      case 'die':   __beep(120,0.20,'sawtooth',0.25); break;
      case 'power': __beep(520,0.06,'triangle',0.18); __beep(640,0.06,'triangle',0.18); break;
      case 'jump':  __beep(420,0.07,'square',0.16); break;
      case 'boss':  __beep(200,0.12,'sawtooth',0.28); __beep(100,0.20,'sawtooth',0.22); break;
      case 'win':   __beep(600,0.08,'triangle',0.2); __beep(800,0.08,'triangle',0.2); __beep(1000,0.12,'triangle',0.2); break;
    case 'hammer': __beep(720,0.05,'square',0.18); __beep(520,0.05,'square',0.16); break;
    case 'bomb':   __beep(260,0.07,'square',0.18); __beep(220,0.10,'square',0.16); break;
    case 'parry':  __beep(820,0.06,'triangle',0.22); __beep(1020,0.06,'triangle',0.2); break;
    case 'enemyshoot': __beep(560,0.04,'square',0.14); break;
    case 'charge': __beep(180,0.14,'sawtooth',0.18); break;
    }
  }catch(e){}
}
// --- end WebAudio SFX ---
function fit(){
    const scale = Math.max(1, Math.floor(Math.min(window.innerWidth/W, window.innerHeight/H)));
    cvs.style.width = (W*scale)+'px';
    cvs.style.height = (H*scale)+'px';
  }
  window.addEventListener('resize', fit); fit();

  function getMousePos(evt){
    const rect = cvs.getBoundingClientRect();
    const sx = W / rect.width;
    const sy = H / rect.height;
    return { x: (evt.clientX - rect.left) * sx, y: (evt.clientY - rect.top) * sy };
  }

  const keys = new Set();
  
  let ngToggleLatch = false;addEventListener('keydown', e => { keys.add(e.key); if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','x','X','Enter','l','L','y','Y','n','N','Escape',' '].includes(e.key)) e.preventDefault(); });
  addEventListener('keyup', e => keys.delete(e.key));

  // persistence: only HI is saved
  let score = 0;
  let hi = Number(localStorage.getItem('mm_hi')||'0');
  function updateHi(){ if (score>hi){ hi=score; localStorage.setItem('mm_hi', String(hi)); } }

  // New Game+ meta
  let ngPlus = 0;                 // how many loops you've cleared
  let totalLevelsCleared = 0;     // rolls over across loops
  function diffMul(){ return 1 + 0.40*ngPlus; } // difficulty multiplier per NG+ loop
  function currentPrice(it){ return Math.max(1, Math.floor(it.price * Math.pow(2, ngPlus))); }

  // animated background — slightly lighter & more gray
  const moonDots = Array.from({length:420}, () => ({
    x:(Math.random()*W)|0, y:(Math.random()*H)|0, s:Math.random()<.85?1:2, phase:Math.random()*Math.PI*2
  }));
  function drawMoon(){
    ctx.fillStyle = '#666666'; // lighter, neutral gray base
    ctx.fillRect(0,0,W,H);
    for (const d of moonDots){
      d.x -= 0.10; if (d.x < -2) d.x = W + 1;
      d.phase += 0.02;
      const t = (Math.sin(d.phase)+1)/2;
      const shade = 28 + (t*26)|0; // neutral gray dots
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(d.x|0, d.y|0, d.s, d.s);
    }
  }

  // EFFECTS: temporary power-ups (10s)
  const EFFECT_TIME = 600;
  const effects = { boots:0, rapid:0, shield:0, jump:0, spread:0, slow:0 };
  function active(id){ return effects[id] > 0; }
  function tickEffects(){ for (const k in effects){ if (effects[k]>0) effects[k]--; } }

  // HUD — fully left aligned
  function hud(){
    const BAR_H = 10;
    ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,W,BAR_H);
    ctx.fillStyle=COL.INK; ctx.font='7px monospace';

    let x=3;
    const part = (text)=>{ ctx.fillText(text, x, 8); x += (ctx.measureText(text).width|0) + 10; };
    part(`SCORE ${score}`);
    part(`LVL ${level}/50${ngPlus>0? ' NG+'+ngPlus : ''}`);
    part(`CLR ${totalLevelsCleared}`);
    part(`HI ${hi}`);

    // badges row — left aligned beneath
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,BAR_H,W,8);
    x = 3;
    const badge=(glyph)=>{
      ctx.fillStyle=COL.G3; ctx.fillRect(x, BAR_H+1, 8, 6);
      ctx.fillStyle=COL.BG; ctx.fillText(glyph, x+2, BAR_H+7);
      x += 10;
    };
    if (active('boots'))  badge('B');
    if (active('jump'))   badge('J');
    if (active('rapid'))  badge('R');
    if (active('spread')) badge('W');
    if (active('slow'))   badge('T');
    if (active('shield')) badge('S');
  }

 
  class Player{
    constructor(){ this.x=16; this.y=GROUND_Y; this.vx=0; this.vy=0; this.face=1; this.onGround=true; this.cool=0; this.parryCool=0; this.animT=0; }
    get speed(){ return 1.0 + (active('boots')?0.4:0); }
    get delay(){ return active('rapid') ? 12 : 20; }
    get jumpPower(){ return 3.0 + (active('jump')?1.0:0); }
    
    update(){
      if (keys.has('ArrowLeft')) { this.vx = Math.max(this.vx-0.25, -this.speed); this.face=-1; }
      if (keys.has('ArrowRight')){ this.vx = Math.min(this.vx+0.25,  this.speed); this.face=1; }
      if (!keys.has('ArrowLeft') && !keys.has('ArrowRight')) this.vx *= .8;
      const wantsJump = keys.has('ArrowUp') || keys.has(' ');

      // Cuphead-lite parry: if mid-air and pressing jump near a parryable pink bullet
      if (!this.onGround && wantsJump && this.parryCool<=0){
        if (tryParry(this)){
          this.vy = - (this.jumpPower + 0.8); // pop upward
          this.parryCool = 20;
          try{sfx('parry')}catch(e){};
        }
      }

      if (wantsJump && this.onGround){ try{sfx('jump')}catch(e){}; this.vy = -this.jumpPower; this.onGround = false; }
      this.vy += 0.25;
      this.y += this.vy;
      if (this.y >= GROUND_Y){ this.y = GROUND_Y; this.vy=0; this.onGround=true; }
      this.x += this.vx * speedScale();
      this.x = Math.max(4, Math.min(W-12, this.x));
      if ((keys.has('x')||keys.has('X')) && this.cool<=0){
        fireShot(this.x+6*this.face, this.y-6, this.face);
        this.cool = this.delay;
      }
      if (this.cool>0) this.cool--;
      if (this.parryCool>0) this.parryCool--;

      // very crude "walk" animation clock when moving on ground
      const moving = Math.abs(this.vx) > 0.12 && this.onGround;
      if (moving){
        this.animT += 0.25; if (this.animT > Math.PI*2) this.animT -= Math.PI*2;
      } else {
        this.animT = 0;
      }
    }
    draw(){
      const ox=this.x|0, oy=(this.y-16)|0, flip=this.face===1?1:-1, WB=8;
      const P={ RED:'#f00', W:'#fff', BR:'#8b4513', Y:'#ffd400', G:'#00ff66', T:'#00c8c8', BL:'#e0e0e0' };
      const r=(dx,dy,w,h,c)=>{ const x=flip===1?ox+dx:ox+(WB-dx-w); ctx.fillStyle=c; ctx.fillRect(x|0,(oy+dy)|0,w,h); };
      // head/face/bandana
      r(-1,-1,13,2,P.RED); r(0,0,2,2,P.W); r(9,0,2,2,P.W); r(4,1,1,4,P.BR);
      // cheeks/mouth
      r(0,4,8,4,P.Y); r(2,6,4,2,P.G);
      // torso & arms
      r(0,8,8,6,P.T); r(-4,10,4,2,P.T); r(-4,12,2,3,P.T); r(8,10,4,3,P.T);
      // legs (simple alternating up/down by 1px when moving)
      const phase = this.animT>0 ? Math.sin(this.animT) : 0;
      const lOff = (phase>0)? -1 : 0;  // left leg pops up 1px
      const rOff = (phase>0)?  0 : -1; // right leg pops up 1px on alternate beat
      r(0,12 + lOff,2,9,P.T);
      r(6,12 + rOff,2,9,P.T);
      // sword/hand glint
      r(10,10,2,2,P.Y); r(12,11,8,1,P.BL);
    }
  }

  class Shot{
    constructor(x,y,d,vy=0){ this.x=x; this.y=y; this.vx=d*2.0; this.vy=vy; this.dead=false; }
    update(){ this.x+=this.vx; this.y+=this.vy; if(this.x<0||this.x>W||this.y<0||this.y>H) this.dead=true; }
    draw(){ ctx.fillStyle=COL.Y; ctx.fillRect(this.x|0, this.y|0, 3,1); }
  }
  function fireShot(x,y,dir){
    const add = b=>shots.push(b);
    add(new Shot(x,y,dir,0));
    if (active('spread')){
      add(new Shot(x,y,dir, -0.6));
      add(new Shot(x,y,dir,  0.6));
      try{sfx('shoot')}catch(e){};
}
}

  class Enemy{
    constructor(px,py){
      let tries=0;
      do{
        this.x=40+Math.random()*(W-80);
        this.y=40+Math.random()*(H-80);
        tries++;
      } while (tries<20 && Math.hypot((this.x-px),(this.y-py))<50);
      const baseSp = 0.22 + Math.random()*0.20;
      const slowMul = active('slow') ? 0.6 : 1.0;
      this.vx=(Math.random()<.5?-1:1)*baseSp*slowMul;
      this.vy=(Math.random()<.5?-1:1)*baseSp*slowMul;
      this.a = Math.random()*Math.PI*2;
      this.as = (Math.random()<.5?-1:1) * (0.06 + Math.random()*0.06);
      // choose a base color per enemy (varied cubes)
      this.cBase = getLevelColor();
      this.cLight = shadeColor(this.cBase, 0.35);
      this.cDark  = shadeColor(this.cBase, -0.30);
      this.cEdge  = shadeColor(this.cBase, -0.55);
      this.cTop   = shadeColor(this.cBase, 0.55);
      this.dead=false;
    }
    update(){
      const slowMul = active('slow') ? 0.6 : 1.0;
      this.x+=this.vx*slowMul*speedScale(); this.y+=this.vy*slowMul*speedScale();
      this.a += this.as * slowMul; if(this.x<8||this.x>W-8) this.vx*=-1;
      if(this.y<16||this.y>H-12) this.vy*=-1;
    }
    draw(){
      const s = 8; // 8x8 "4-bit" cube
      const x = this.x|0, y = this.y|0;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(this.a);

      // base cube (purple)
      ctx.fillStyle = this.cBase;
      ctx.fillRect(-(s/2)|0, -(s/2)|0, s, s);

      // edge / outline for 4-bit pop
      ctx.strokeStyle = this.cEdge;
      ctx.strokeRect(-(s/2)|0, -(s/2)|0, s, s);

      // "mean face" in low-res pixels (use black/white)
      // eyebrows (slanted down toward center)
      ctx.strokeStyle = COL.BG;
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(-2, -2); ctx.lineTo(0, -3); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(2, -2); ctx.lineTo(0, -3); ctx.stroke();

      // eyes
      ctx.fillStyle = COL.INK;
      ctx.fillRect(-2, -1, 1, 1);
      ctx.fillRect(1, -1, 1, 1);

      // frown (blocky)
      ctx.fillStyle = COL.BG;
      ctx.fillRect(-2, 2, 1, 1);
      ctx.fillRect(-1, 3, 3, 1);
      ctx.fillRect(2, 2, 1, 1);

      ctx.restore();
    } }
  class Hazard{
    constructor(x,y,vx,vy){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.dead=false; }
    update(){ this.x+=this.vx; this.y+=this.vy; if(this.x<2||this.x>W-2) this.vx*=-1; if(this.y<2||this.y>H-12) this.vy*=-1; }
    draw(){ ctx.fillStyle=COL.G2; ctx.fillRect((this.x-1)|0,(this.y-1)|0,2,2); }
  }
  
class Gorg{
  constructor(){
    // Big boss aligned to the ground line
    this.w = 140;
    this.h = Math.round(this.w * (GORG_IMG.height / Math.max(1, GORG_IMG.width)));
    this.x = W - this.w - 20;
    this.y = GROUND_Y; // baseline (feet)
    this.hp = BOSS_MAX_HP; this.hitFlash=0;
    this.dead = false;
    this.t = 0;
  }
  draw(){
    if (!GORG_READY) return;
    const bob = Math.sin(this.t)*2.0;
    const top = (this.y - this.h) + bob;
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(GORG_IMG, this.x|0, top|0, this.w|0, this.h|0);
    ctx.restore();
    this.t += 0.06;
  
    // hit flash overlay
    if (this.hitFlash>0){
      ctx.fillStyle='rgba(255,255,255,0.35)';
      ctx.fillRect(this.x, (this.y - (this.h||60))|0, (this.w||60), (this.h||60));
      this.hitFlash--;
    }
  }
}


  function drawKey(x,y){ ctx.fillStyle=COL.Y; ctx.fillRect(x|0,y|0,6,6); ctx.fillStyle=COL.BG; ctx.fillRect((x+2)|0,(y+2)|0,2,2); ctx.fillStyle=COL.Y; ctx.fillRect((x+6)|0,(y+2)|0,10,2); ctx.fillRect((x+14)|0,y|0,2,2); ctx.fillRect((x+12)|0,(y+4)|0,2,2); }

  let state='TITLE';
  let level=1, MAX_LEVEL=50;
  function speedScale(){ return (level>15) ? 0.85 : 1.0; }
  let player, shots=[], enemies=[], hazards=[], boss=null, bossShots=[], spaceships=[], spaceBombs=[], crabs=[], shooters=[], chargers=[], enemyBullets=[];
  let SHOOTER_SEQ = 0;
  let goalX=W-26, goalY=GROUND_Y-10, goalT=0;
  let hazardTimer=0, hazardInterval=115;
  let msgTimer=0;

  let selectedLevel=1;
  // Title-screen ambiance
  let titleHammers=[]; let titleAngle=0; let titleGorgT=0;
  const BOSS_MAX_HP = 40;
  let bossBooms = []; // explosion particles when boss dies
  let screenFlash = 0;

  let bossThrowTimer=0, bossThrowInterval=70;

  const SHOP_LEVELS = new Set([5,10,15,20,25,30,35,40,45,49]);
  let postShopState='PLAY';
  let shopFlash=0, lastClickMsg='';
  const shopItems = [
    { id:'boots',  name:'Energy Bar', price:25, icon:'B', timed:true },
    { id:'jump',   name:'Electric Shoes',  price:25, icon:'J', timed:true },
    { id:'rapid',  name:'Extra Craps',   price:100, icon:'R', timed:true },
    { id:'spread', name:'Moon Master Stickers', price:150, icon:'W', timed:true },
    { id:'slow',   name:'Moonajuana',   price:500, icon:'T', timed:true }, // slows enemies & hazards
    { id:'shield', name:'Helmet',      price:500, icon:'S', timed:true },
    { id:'erase',  name:'Gorgatron Repellent', price:9999, icon:'-', timed:false } // instant: remove 2 enemies
  ];

  cvs.addEventListener('click', (e)=>{
    const m = getMousePos(e);
    if (state==='TITLE'){ state='PLAY'; startLevel(); return; }
    if (state==='SHOP'){
      const startY=50;
      for (let i=0;i<shopItems.length;i++){
        const y = startY + i*18;
        if (m.y>=y-8 && m.y<=y+4){ activateItem(i); return; }
      }
      if (m.x>=20 && m.x<=120 && m.y>=H-30 && m.y<=H-16){ state = postShopState; startLevel(); return; }
    }
  });

  function activateItem(i){
    const it = shopItems[i];
    const price = currentPrice(it);
    if (score>=price){
      score -= price; try{sfx('power')}catch(e){};
      if (it.timed){
        effects[it.id] = EFFECT_TIME; // start/refresh 10s
        lastClickMsg = `${it.name} activated for 10s.`;
      } else {
        let removed=0;
        enemies = enemies.filter(e => {
          if (removed<2){ removed++; return false; }
          return true;
        });
        lastClickMsg = removed>0 ? `Removed ${removed} enemies.` : `No enemies to remove.`;
      }
      shopFlash=16;
    } else { lastClickMsg = `Not enough funds for ${it.name}.`; shopFlash=16; }
  }

 function initTitleAmbience(){
    titleHammers=[]; titleAngle=0; titleGorgT=0;
    const N = 8;
    const R = Math.min(W,H)/2 - 20;
    for (let i=0;i<N;i++){
      titleHammers.push({ a:i*(Math.PI*2/N), s:6, rot:Math.random()*Math.PI*2, rs:0.07+Math.random()*0.03 });
    }
  }
  function drawTitle(){
    // init one-time
    if (titleHammers.length===0) initTitleAmbience();
    // rotating projectiles around the screen for ambiance
    titleAngle += 0.012;
    const cx = W/2, cy = H/2, R = Math.min(W,H)/2 - 20;
    for (const o of titleHammers){
      const x = cx + Math.cos(o.a + titleAngle) * R;
      const y = cy + Math.sin(o.a + titleAngle) * R;
      o.rot += o.rs;
      const s = o.s;
      ctx.save();
      ctx.translate(x|0, y|0);
      ctx.rotate(o.rot);
      ctx.fillStyle = COL.Y;
      ctx.fillRect(-(s/2)|0, -(s/2)|0, s, s);
      ctx.strokeStyle = shadeColor(COL.Y,-0.5);
      ctx.strokeRect(-(s/2)|0, -(s/2)|0, s, s);
      ctx.restore();
    }

    // Gorgatron bobbing on title (same sprite as boss)
    if (typeof GORG_READY!=='undefined' && GORG_READY){
      titleGorgT += 0.05;
      const gw = 90;
      const gh = Math.round(gw * (GORG_IMG.height / Math.max(1, GORG_IMG.width)));
      const gx = W - gw - 18;
      const gy = 86 + Math.sin(titleGorgT)*2;
      ctx.save(); ctx.imageSmoothingEnabled=false;
      ctx.drawImage(GORG_IMG, gx|0, (gy-gh)|0, gw|0, gh|0);
      ctx.restore();
    }

    ctx.fillStyle=COL.INK; ctx.font='bold 12px monospace'; ctx.fillText('MOON MASTER', 84, 56);
    ctx.font='8px monospace';
    ctx.fillStyle=COL.G1; ctx.fillText('Beware the Gorgotron', 68, 74);
    ctx.fillStyle=COL.G3; ctx.fillText('Press Enter or Click to begin', 58, 90);    if (keys.has('Enter')) { state='PLAY'; startLevel(); }
    if (keys.has('l')||keys.has('L')){ selectedLevel=level; state='LEVEL_SELECT'; }
    if (keys.has('k')||keys.has('K')){ state='CREDITS'; }
    // Debug: toggle New Game+ with J
    if ((keys.has('j')||keys.has('J')) && !ngToggleLatch){ ngPlus = ngPlus?0:1; ngToggleLatch = true; try{sfx('menu')}catch(e){}; }
    if (!keys.has('j') && !keys.has('J')) ngToggleLatch = false;

  }


  function drawCredits(){
    ctx.fillStyle='rgba(0,0,0,.75)'; ctx.fillRect(0,0,W,H);
    const prev = ctx.textAlign; ctx.textAlign='center';

    ctx.fillStyle=COL.INK;
    ctx.font='bold 12px monospace';
    ctx.fillText('', W/2, 68);

    ctx.font='10px monospace';
    ctx.fillText('Fancy Secret Credit Screen!', W/2, 88);
    ctx.fillText('Developed by u/0hmyTVC15', W/2, 108);

    ctx.fillStyle=COL.G3;
    ctx.font='8px monospace';
    ctx.fillText('Press Esc to return', W/2, H-24);

    ctx.textAlign=prev;

    if (keys.has('Escape') || keys.has('Enter')) state='TITLE';
  }

  function drawLevelSelect(){
    ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle=COL.INK; ctx.font='bold 10px monospace'; ctx.fillText('LEVEL SELECT', 54, 40);
    ctx.font='8px monospace';
    ctx.fillText('←/→ = ±1   ↑/↓ = ±10', 20, 58);
    ctx.fillText('Selected: '+selectedLevel, 96, 76);
    if (keys.has('ArrowRight')) selectedLevel=Math.min(MAX_LEVEL, selectedLevel+1);
    if (keys.has('ArrowLeft'))  selectedLevel=Math.max(1, selectedLevel-1);
    if (keys.has('ArrowUp'))    selectedLevel=Math.min(MAX_LEVEL, selectedLevel+10);
    if (keys.has('ArrowDown'))  selectedLevel=Math.max(1, selectedLevel-10);
    if (keys.has('Enter')){
      level=selectedLevel;
      const next = (level===MAX_LEVEL)?'BOSS':'PLAY';
      if (SHOP_LEVELS.has(level)){ state='SHOP'; postShopState=next; startLevel(); } else { state=next; startLevel(); }
    }
    if (keys.has('Escape')) state='TITLE';
  }

  function enemyCountForLevel(lvl){
    const extra = Math.floor((lvl-1)/2)*2;
    return Math.min(16, 2 + extra);
  }

  function startLevel(){
    
    /* ensure boss at last level */
    if (level===MAX_LEVEL && state!=='BOSS') { state='BOSS'; }
player=new Player(); shots=[]; enemies=[]; hazards=[]; boss=null; spaceships=[]; spaceBombs=[]; shooters=[]; chargers=[]; enemyBullets=[];
    SHOOTER_SEQ=0;
    goalX=W-26; goalY=GROUND_Y-10;
    const ecount = enemyCountForLevel(level);
    if (state==='PLAY'){ 
      for(let i=0;i<ecount;i++) enemies.push(new Enemy(player.x, player.y)); 
      // Cuphead-lite: add new enemy types
      // Shooters (floating orbs)
      if (level>=6){
        const nShoot = Math.min(2, Math.min(6, 1 + Math.floor((level-6)/6) + (ngPlus>0?1:0)));
        for (let s=0;s<nShoot;s++) shooters.push(new Shooter(player.x, player.y));
      
      if (shooters.length > 2) shooters = shooters.slice(0, 2);
}
      // Chargers (telegraphed dashes)
      if (level>=10){
        const nChg = Math.min(4, 1 + Math.floor((level-10)/10) + (ngPlus>0?1:0));
        for (let c=0;c<nChg;c++) chargers.push(new Charger(Math.random()<.5?'L':'R'));
      }
      if (level>7){
        // 1 ship after 20, 2 ships after 30
        const numShips = (level>=15)?2:1;
        for (let s=0;s<numShips;s++){
          const side = Math.random()<.5? 'L':'R';
          const sx = (side==='L')? 6 : W-18;
          const dir = (side==='L')? 1 : -1;
          if (spaceships.length < 2) spaceships.push(new SpaceShip(sx, 28+Math.random()*16, dir));
        }
      }
    }
    if (state==='BOSS'){ boss=new Gorg();
      // add spaceships during boss battle
      {
        const nShips = Math.min(3, 1 + (ngPlus||0));
        for (let i=0;i<nShips;i++){
          const side = Math.random()<.5? 'L':'R';
          const dir = (side==='L')? 1 : -1;
          const sx = side==='L'? 8 : W-20;
          if (spaceships.length < 2) spaceships.push(new SpaceShip(sx, 28+Math.random()*16, dir));
        }
      }

    // ground crabs after level 15
    if (state==='PLAY' && level>15){
      const nCrabs = Math.min(3, 1 + Math.floor((level-16)/6)); // 1..3
      for (let i=0;i<nCrabs;i++){
        const side = Math.random()<.5? 'L':'R';
        crabs.push(new Crab(side));
      }
    }
 try{sfx('boss')}catch(e){}; bossShots=[]; bossThrowInterval = Math.max(32, 70 - Math.floor(level*1.2)); bossThrowTimer = 24; }
    const baseInterval = 115 - Math.floor((level-1)*1.3);
    const slowBonus = active('slow')? 25 : 0;
    hazardInterval = Math.max(35, Math.floor(baseInterval / diffMul()) + slowBonus);
    hazardTimer = hazardInterval;
    msgTimer = 48;
  }

  function nextAfterClear(){ try{sfx('win')}catch(e){};
    score+=100; updateHi();
    totalLevelsCleared++;
    level++;
    if (level>MAX_LEVEL){ state='ENDING'; return; }
    const next = (level===MAX_LEVEL)?'BOSS':'PLAY';
    if (SHOP_LEVELS.has(level)){ state='SHOP'; postShopState=next; } else { state=next; }
    startLevel();
  }

  function nextAfterBoss(){ try{sfx('win')}catch(e){};
    score+=300; updateHi();
    totalLevelsCleared++;
    level++;
    if (level>MAX_LEVEL){ state='ENDING'; return; }
    const next = (level===MAX_LEVEL)?'BOSS':'PLAY';
    if (SHOP_LEVELS.has(level)){ state='SHOP'; postShopState=next; } else { state=next; }
    startLevel();
  }

  function onDeath(from){ try{sfx('die')}catch(e){};
    if (active('shield')){ effects.shield = 0; state=from; startLevel(); return; }
    updateHi();
    score = 0;
    state='CONTINUE'; resumeState=from;
  }
  let resumeState='PLAY';

  function drawContinue(){
    ctx.fillStyle='rgba(0,0,0,.7)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle=COL.INK; ctx.font='bold 8px monospace'; ctx.fillText('YOU HAVE INSTANTLY TURNED TO VAPOR', 60, 70);
    ctx.font='8px monospace'; ctx.fillText(`Continue at Level ${level}?  (Y / N)`, 70, 88);
    if (keys.has('y')||keys.has('Y')||keys.has('Enter')){ state=resumeState; startLevel(); }
    if (keys.has('n')||keys.has('N')||keys.has('Escape')){ state='TITLE'; }
  }

  function drawShop(){
      ctx.fillStyle = COL.INK; ctx.font = 'bold 9px monospace'; ctx.fillText('UNBELIEVABLE!', 18, 24);
      ctx.font = '8px monospace';
      ctx.fillStyle = COL.G3; ctx.fillText('What you need now is our free warrior kit ...', 16, 36);

      const startY = 50;
      shopItems.forEach((it, idx)=>{
        const y = startY + idx*18;
        if (shopFlash>0) ctx.fillStyle = (shopFlash%2?COL.Y:COL.INK); else ctx.fillStyle=COL.INK;
        ctx.fillText(`${it.name}`, 16, y);
        ctx.fillStyle = COL.G2; ctx.fillText(`$${currentPrice(it)}`, 170, y);
      });
      if (shopFlash>0) shopFlash--;

      ctx.fillStyle = COL.G2; ctx.fillRect(20, H-30, 100, 14);
      ctx.fillStyle = COL.BG; ctx.fillText('CONTINUE →', 40, H-19);

      ctx.fillStyle = COL.G1; ctx.fillText(lastClickMsg || 'All sales are non-refundable.', 12, H-6);

      if (keys.has('Enter')) { state=postShopState; startLevel(); }
  }
// --- Spaceship enemy (appears after level 20) ---
class SpaceBomb{
  constructor(x,y){
    this.x=x; this.y=y; this.vx=(Math.random()-.5)*0.4; this.vy=-0.4;
    this.a=0; this.as=(Math.random()<.5?-1:1)*0.25;
    this.dead=false;
  }
  update(){
    this.vy += 0.18;
    this.x += this.vx * speedScale();
    this.y += this.vy;
    this.a += this.as;
    if (this.y>H-10) this.dead=true;
  }
  draw(){
    const s=4, x=this.x|0, y=this.y|0;
    ctx.save(); ctx.translate(x,y); ctx.rotate(this.a);
    ctx.fillStyle=COL.Y; ctx.fillRect(-(s/2)|0, -(s/2)|0, s, s);
    ctx.strokeStyle=shadeColor(COL.Y,-0.5); ctx.strokeRect(-(s/2)|0, -(s/2)|0, s, s);
    ctx.restore();
  }
}

class SpaceShip{
  constructor(x,y,dir){
    this.x=x; this.y=y; this.dir=dir;
    this.vx = 0.60*dir;
    this.hp = 4;
    this.dead=false;
    this.dropTimer = 36 + (Math.random()*24)|0;
  }
  update(){
    this.x += this.vx * speedScale();
    if (this.x<6){ this.x=6; this.vx=Math.abs(this.vx); }
    if (this.x>W-18){ this.x=W-18; this.vx=-Math.abs(this.vx); }
    if (--this.dropTimer<=0){
      spaceBombs.push(new SpaceBomb(this.x+6, this.y+6));
      this.dropTimer = 42 - Math.min(14, Math.floor((level-20)*0.8)) + ((Math.random()*10)|0);
      try{sfx('bomb')}catch(e){};
    }
  }
  draw(){
    const x=(this.x|0), y=(this.y|0);
    // 4-bit style little craft
    ctx.fillStyle=getLevelColor(); ctx.fillRect(x, y, 12, 6);
    ctx.fillStyle=COL.INK; ctx.fillRect(x+2, y+2, 2, 2); // window
    ctx.fillStyle=COL.G1; ctx.fillRect(x-2, y+2, 2, 2);   // left fin
    ctx.fillRect(x+12, y+2, 2, 2);                       // right fin
  }
}
// --- end spaceship enemy ---
// --- Crab enemy (appears after level 15) ---
class Crab{
  constructor(side='L'){
    this.y = GROUND_Y - 4;
    this.x = side==='L' ? 4 : W-12;
    this.vx = (side==='L'? 1 : -1) * (0.35 + Math.min(0.9, 0.015*(level-15)));
    this.frame = 0;
    this.dead=false;
  }
  update(){
    const slowMul = active('slow') ? 0.6 : 1.0;
    this.x += this.vx * slowMul * speedScale();
    if (this.x <= 4){ this.x = 4; this.vx = Math.abs(this.vx); }
    if (this.x >= W-12){ this.x = W-12; this.vx = -Math.abs(this.vx); }
    this.frame = (this.frame+1)%20;
  }
  draw(){
    const x = this.x|0, y = (this.y-4)|0;
    // body
    ctx.fillStyle = getLevelColor(); ctx.fillRect(x, y, 8, 4);
    // legs (flip every few frames)
    const up = this.frame<10;
    ctx.fillRect(x-1, y+(up?4:3), 2, 1);
    ctx.fillRect(x+7, y+(up?3:4), 2, 1);
    // eyes
    ctx.fillStyle = COL.INK; ctx.fillRect(x+2, y-1, 1, 1); ctx.fillRect(x+5, y-1, 1, 1);
  }
}

// --- Parry helper (Cuphead-lite) ---
function tryParry(pl){
  for (const b of enemyBullets){
    if (b.parryable && !b.dead){
      const dx = pl.x - b.x, dy = pl.y - b.y;
      if (Math.abs(dx) < 7 && Math.abs(dy) < 8){
        b.dead = true;
        score += 15; updateHi();
        return true;
      }
    }
  }
  return false;
}

// --- Enemy bullet (from Shooter etc.) ---
class EnemyBullet{
  constructor(x,y,vx,vy, parryable=false, ownerId=null){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.dead=false; this.parryable=parryable;
   this.ownerId = ownerId;}
  update(){
    const __ENEMY_BULLET_MUL = 0.6;
    this.x += this.vx * speedScale() * __ENEMY_BULLET_MUL; this.y += this.vy * __ENEMY_BULLET_MUL;
    if (this.x<-6||this.x>W+6||this.y<-6||this.y>H+6) this.dead=true;
  }
  draw(){
    const s = 3;
    const x=this.x|0, y=this.y|0;
    if (this.parryable){
      // pink, parryable (Cuphead style)
      ctx.fillStyle = '#ff77cc';
      ctx.fillRect(x, y, s, s);
      ctx.strokeStyle = '#992255'; ctx.strokeRect(x, y, s, s);
    } else {
      ctx.fillStyle = COL.Y; ctx.fillRect(x, y, s, s);
    }
  }
}

// --- Shooter enemy: floats, fires aimed shots (some pink = parryable) ---
class Shooter{
  constructor(px,py){
    let tries=0;
    do{
      this.x = 30 + Math.random()*(W-60);
      this.y = 30 + Math.random()*(H-70);
      tries++;
    } while(tries<20 && Math.hypot(this.x-px, this.y-py)<70);
    this.vx = (Math.random()<.5?-1:1) * (0.25 + Math.random()*0.15);
    this.vy = (Math.random()<.5?-1:1) * (0.18 + Math.random()*0.12);
    this.t = 30 + (Math.random()*40)|0;
    this.hp = 3;
    this.dead=false;
    this.c = getLevelColor();
  }
  update(){
    const slowMul = active('slow') ? 0.75 : 1.0;
    this.x += this.vx * slowMul * speedScale(); this.y += this.vy * slowMul * speedScale();
    if (this.x<10||this.x>W-10) this.vx*=-1;
    if (this.y<14||this.y>H-18) this.vy*=-1;
    if (--this.t<=0){
      const dx = player.x - this.x, dy = player.y - this.y;
      const L = Math.max(1, Math.hypot(dx,dy));
      const sp = (1.2 + Math.min(0.8, level*0.02)) * diffMul();
      const parryable = Math.random() < 0.35; // ~35% pink shots
      const countMine = enemyBullets.reduce((n,b)=> n + (!b.dead && b.ownerId===this.id ? 1 : 0), 0);
      if (countMine < 3){
        enemyBullets.push(new EnemyBullet(this.x, this.y, (dx/L)*sp, (dy/L)*sp, parryable, this.id));
        try{sfx('enemyshoot')}catch(e){};
        this.t = 44 - Math.min(20, Math.floor(level*0.6)) + ((Math.random()*12)|0);
      } else {
        this.t = 10; // throttle while at bullet cap
      }
    }
  }
  draw(){
    const s=8;
    const x=this.x|0, y=this.y|0;
    // little orb with telegraph "eye"
    ctx.fillStyle = this.c;
    ctx.fillRect(x-((s>>1)), y-((s>>1)), s, s);
    ctx.fillStyle = COL.INK;
    ctx.fillRect(x-1, y-2, 2, 2); // eye
  }
}

// --- Charger enemy: flashes, then dashes horizontally toward player ---
class Charger{
  constructor(side='L'){
    this.y = 36 + Math.random()*(H-72);
    this.x = side==='L'? 6 : W-14;
    this.dir = side==='L'? 1 : -1;
    this.state = 'windup'; // windup -> dash -> recover
    this.timer = 30 + ((Math.random()*20)|0);
    this.vx = 0;
    this.hp = 3;
    this.dead=false;
    this.c = getLevelColor();
  }
  update(){
    const slowMul = active('slow') ? 0.75 : 1.0;
    if (this.state==='windup'){
      if (--this.timer<=0){
        this.state='dash'; this.timer = 24;
        this.vx = (2.4 + Math.min(1.4, level*0.04)) * diffMul() * this.dir * slowMul;
        try{sfx('charge')}catch(e){};
      }
    } else if (this.state==='dash'){
      this.x += this.vx * speedScale();
      if (--this.timer<=0 || this.x<4 || this.x>W-10){
        this.state='recover'; this.timer = 28;
        this.vx = 0; this.dir *= -1;
      }
    } else { // recover
      if (--this.timer<=0){ this.state='windup'; this.timer = 30; }
    }
    this.y += Math.sin(performance.now()/180 + this.x*0.05)*0.05; // tiny wiggle
    this.x = Math.max(4, Math.min(W-10, this.x));
  }
  draw(){
    const x=this.x|0, y=this.y|0;
    const s=8;
    if (this.state==='windup' && (this.timer%6<3)){
      ctx.fillStyle = '#ffffff'; // flash telegraph
    } else {
      ctx.fillStyle = this.c;
    }
    ctx.fillRect(x-((s>>1)), y-((s>>1)), s, s);
    // angry mouth
    ctx.fillStyle = COL.BG;
    ctx.fillRect(x-2, y+1, 4, 1);
  }
}


function drawPlay(){
    if (--hazardTimer<=0){ spawnHazard(false); hazardTimer = hazardInterval; }
    player.update();
    enemies.forEach(e=>e.update());
    shooters.forEach(s=>s.update());
    chargers.forEach(c=>c.update());
    enemyBullets.forEach(b=>b.update());
    hazards.forEach(h=>h.update());
    spaceships.forEach(s=>s.update());
    spaceBombs.forEach(b=>b.update());
        crabs.forEach(c=>c.update());
tickEffects();

    for (const e of enemies){
      if (Math.abs(player.x-e.x)<8 && Math.abs(player.y-e.y)<10) { onDeath('PLAY'); return; }
    }
    for (const e of chargers){ if (Math.abs(player.x-e.x)<7 && Math.abs(player.y-e.y)<8) { onDeath('PLAY'); return; } }
    for (const e of chargers){ if (Math.abs(player.x-e.x)<7 && Math.abs(player.y-e.y)<8){ onDeath('PLAY'); return; } }
  for (const b of enemyBullets){ if (!b.dead && Math.abs(player.x-b.x)<5 && Math.abs(player.y-b.y)<6){ onDeath('PLAY'); return; } }
  for (const h of hazards){
      if (Math.abs(player.x-h.x)<5 && Math.abs(player.y-h.y)<6) { onDeath('PLAY'); return; }
    }
    for (const b of enemyBullets){ if (!b.dead && Math.abs(player.x-b.x)<5 && Math.abs(player.y-b.y)<6){ onDeath('PLAY'); return; } }
    for (const b of spaceBombs){
      if (Math.abs(player.x-b.x)<5 && Math.abs(player.y-b.y)<6) { onDeath('PLAY'); return; }
        for (const c of crabs){
      if (Math.abs(player.x-c.x)<6 && Math.abs(player.y-c.y)<8) { onDeath('PLAY'); return; }
    }
}
    shots.forEach(s=>{
      s.update();
      enemies.forEach(e=>{ if (!e.dead && Math.abs(s.x-e.x)<6 && Math.abs(s.y-e.y)<6){ e.dead=true; s.dead=true; score+=10; updateHi(); try{sfx('hit')}catch(e){}; } });
      shooters.forEach(en=>{ if (!en.dead && Math.abs(s.x-en.x)<6 && Math.abs(s.y-en.y)<6){ en.hp--; s.dead=true; if (en.hp<=0){ en.dead=true; score+=15; updateHi(); } } });
      chargers.forEach(en=>{ if (!en.dead && Math.abs(s.x-en.x)<6 && Math.abs(s.y-en.y)<6){ en.hp--; s.dead=true; if (en.hp<=0){ en.dead=true; score+=15; updateHi(); } } });
      enemyBullets.forEach(b=>{ if(!b.dead && Math.abs(s.x-b.x)<4 && Math.abs(s.y-b.y)<4){ b.dead=true; s.dead=true; } });
      hazards.forEach(h=>{ if (!h.dead && Math.abs(s.x-h.x)<3 && Math.abs(s.y-h.y)<3){ h.dead=true; s.dead=true; } });
      spaceships.forEach(sp=>{ if(!sp.dead && s.x>sp.x-1 && s.x<sp.x+13 && s.y>sp.y-1 && s.y<sp.y+7){ sp.hp--; s.dead=true; if(sp.hp<=0){ sp.dead=true; score+=20; updateHi(); } } });
      spaceBombs.forEach(b=>{ if(!b.dead && Math.abs(s.x-b.x)<4 && Math.abs(s.y-b.y)<4){ b.dead=true; s.dead=true; } });
    });
    enemies = enemies.filter(e=>!e.dead);
    shooters = shooters.filter(e=>!e.dead);
    chargers = chargers.filter(e=>!e.dead);
    enemyBullets = enemyBullets.filter(b=>!b.dead);
    crabs = crabs.filter(c=>!c.dead);
    spaceships = spaceships.filter(s=>!s.dead);
    spaceBombs = spaceBombs.filter(b=>!b.dead);
    shots = shots.filter(s=>!s.dead);
    hazards = hazards.filter(h=>!h.dead);

    // Key is present every level: static BR through L25, moves vertically from L26+
    goalT += 0.05;
    goalX = W - 26;
    if (level <= 25){
      goalY = GROUND_Y - 10; // fixed in bottom-right
    } else {
      const top = 10, bottom = GROUND_Y - 10;
      const mid = (top + bottom)/2, amp = (bottom - top)/2;
      goalY = mid + amp * Math.cos(goalT); // vertical sweep along right edge
    }
    if (Math.abs(player.x - (goalX+8))<10 && Math.abs(player.y - (goalY+4))<12){ nextAfterClear(); return; }

    drawKey(goalX, goalY);
    enemies.forEach(e=>e.draw());
    shooters.forEach(e=>e.draw());
    chargers.forEach(e=>e.draw());
    enemyBullets.forEach(b=>b.draw());
    hazards.forEach(h=>h.draw());
    crabs.forEach(c=>c.draw());
    spaceBombs.forEach(b=>b.draw());
    spaceships.forEach(s=>s.draw());
    shots.forEach(s=>s.draw());
    player.draw();
    if (msgTimer>0){ msgTimer--; ctx.fillStyle=COL.INK; ctx.fillText('GET THE GOLD KEY!', 32, 20); }
  }

  

class BossHammer{
  constructor(x,y,vx,vy){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy;
    this.a=0; this.as = (Math.random()<.5?-1:1)*(0.3+Math.random()*0.3);
    this.dead=false; this.age=0;
  }
  update(){
    this.vy += 0.12; // gravity
    const __BOSS_HAMMER_MUL = 0.6; // gravity
    this.x += this.vx * speedScale() * __BOSS_HAMMER_MUL;
    this.y += this.vy * __BOSS_HAMMER_MUL;
    this.a += this.as;
    this.age++;
    if (this.y > H+12 || this.x < -12 || this.x > W+12 || this.age>360) this.dead=true;
  }
  draw(){
    const s=6;
    const x=this.x|0, y=this.y|0;
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(this.a);
    ctx.fillStyle = COL.Y;
    ctx.fillRect(-(s/2)|0, -(s/2)|0, s, s);
    ctx.strokeStyle = shadeColor(COL.Y,-0.5);
    ctx.strokeRect(-(s/2)|0, -(s/2)|0, s, s);
    ctx.restore();
  }
}


// --- Boss explosion particles ---
class Boom{
  constructor(x,y){
    this.x=x; this.y=y;
    this.vx = (Math.random()*4-2);
    this.vy = (Math.random()*-3-1.5);
    this.a = Math.random()*Math.PI*2;
    this.as = (Math.random()<.5?-1:1)*(0.2+Math.random()*0.3);
    this.life = 60 + (Math.random()*30)|0;
  }
  update(){
    this.vy += 0.08;
    this.x += this.vx * speedScale(); this.y += this.vy;
    this.a += this.as;
    this.life--;
  }
  draw(){
    const s = 4;
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.a);
    ctx.fillStyle = Math.random()<.6? COL.Y : getLevelColor();
    ctx.fillRect(-s/2, -s/2, s, s);
    ctx.restore();
  }
}
function triggerBossExplosion(){
  if (!boss) return;
  const bx = boss.x + (boss.w||60)/2;
  const by = boss.y - (boss.h||60)/2;
  for (let i=0;i<80;i++) bossBooms.push(new Boom(bx, by));
  screenFlash = 12;
}
function drawBoss(){
  if (--hazardTimer<=0){ spawnHazard(true); hazardTimer = Math.max(55, hazardInterval+35); }
  player.update();
  hazards.forEach(h=>h.update());
  shooters.forEach(s=>s.update());
  chargers.forEach(c=>c.update());
  enemyBullets.forEach(b=>b.update());
    spaceships.forEach(s=>s.update());
    spaceBombs.forEach(b=>b.update());
      crabs.forEach(c=>c.update());
tickEffects();
    // Boss projectile patterns: fan, aimed, rain, and random arcs
    if (--bossThrowTimer<=0 && boss && !boss.dead){
      const pattern = (Math.random()<0.25)?'fan':(Math.random()<0.5?'rain':(Math.random()<0.5?'aimed':'random'));
      const fromX = boss.x + (boss.w||60) - 16;
      const fromY = (boss.y - (boss.h||60)) + 24;
      const g = 0.12;
      
      function tossTo(tx, ty, Tmul=1){
        const T = (26 + Math.random()*28) * Tmul;
        const spx = (tx - fromX) / T;
        const spy = (ty - fromY) / T - 0.5*g*T;
        const maxVX = 3.8*diffMul(), maxVY=3.4*diffMul();
        const vx = Math.max(-maxVX, Math.min(maxVX, spx));
        const vy = Math.max(-maxVY, Math.min(maxVY, spy));
        bossShots.push(new BossHammer(fromX, fromY, vx, vy));
      }

      if (pattern==='fan'){
        const midX = player.x, midY = player.y;
        for (let i=-2;i<=2;i++){
          tossTo(midX + i*24, midY + i*2, 0.9 + Math.abs(i)*0.05);
        }
      } else if (pattern==='rain'){
        for (let i=0;i<6;i++){
          const tx = 12 + Math.random()*(W-24);
          const ty = 20 + Math.random()*10;
          tossTo(tx, ty, 1.2);
        }
      } else if (pattern==='aimed'){
        const tx = player.x + (Math.random()*30-15);
        const ty = player.y + (Math.random()*10-5);
        for (let i=0;i<3;i++) tossTo(tx + i*8 - 8, ty - i*2, 1.0);
      } else { // random
        const throws = 2 + Math.min(3, ngPlus||0);
        for (let t=0;t<throws;t++){
          const tx = 16 + Math.random()*(W-32);
          const ty = 24 + Math.random()*(H-48);
          tossTo(tx, ty, 1.0);
        }
      }

      try{sfx('enemyshoot')}catch(e){};
      bossThrowInterval = Math.max(18, Math.floor((68 - Math.floor(level*1.2)) / diffMul()));
      bossThrowTimer = bossThrowInterval;
    }bossShots.forEach(h=>h.update());


  // Shots & collisions
  shots.forEach(s=>{
    s.update();
    shooters.forEach(en=>{ if (!en.dead && Math.abs(s.x-en.x)<6 && Math.abs(s.y-en.y)<6){ en.hp--; s.dead=true; if (en.hp<=0){ en.dead=true; score+=15; updateHi(); } } });
    chargers.forEach(en=>{ if (!en.dead && Math.abs(s.x-en.x)<6 && Math.abs(s.y-en.y)<6){ en.hp--; s.dead=true; if (en.hp<=0){ en.dead=true; score+=15; updateHi(); } } });
    enemyBullets.forEach(b=>{ if(!b.dead && Math.abs(s.x-b.x)<4 && Math.abs(s.y-b.y)<4){ b.dead=true; s.dead=true; } });
    if (boss && !boss.dead){
      const bx0 = boss.x, by0 = boss.y - (boss.h||60);
      const bx1 = boss.x + (boss.w||60), by1 = boss.y;
      if (s.x>bx0 && s.x<bx1 && s.y>by0 && s.y<by1){
        boss.hp--; s.dead=true; try{sfx('hitboss')}catch(e){}; boss.hitFlash = 6;
        if (boss.hp<=0){ boss.dead=true; msgTimer=60; triggerBossExplosion(); try{sfx('bomb')}catch(e){}; }
      }
    }
    hazards.forEach(h=>{ if (!h.dead && Math.abs(s.x-h.x)<3 && Math.abs(s.y-h.y)<3){ h.dead=true; s.dead=true; } });
      spaceships.forEach(sp=>{ if(!sp.dead && s.x>sp.x-1 && s.x<sp.x+13 && s.y>sp.y-1 && s.y<sp.y+7){ sp.hp--; s.dead=true; if(sp.hp<=0){ sp.dead=true; score+=20; updateHi(); } } });
      spaceBombs.forEach(b=>{ if(!b.dead && Math.abs(s.x-b.x)<4 && Math.abs(s.y-b.y)<4){ b.dead=true; s.dead=true; } });
  });

  for (const e of chargers){ if (Math.abs(player.x-e.x)<7 && Math.abs(player.y-e.y)<8){ onDeath('BOSS'); return; } }
  for (const b of enemyBullets){ if (!b.dead && Math.abs(player.x-b.x)<5 && Math.abs(player.y-b.y)<6){ onDeath('BOSS'); return; } }
  for (const h of hazards){
    if (Math.abs(player.x-h.x)<5 && Math.abs(player.y-h.y)<6){ onDeath('BOSS'); return; }
  }

  
    // Player collision with boss hammers
    for (const bh of bossShots){
      if (Math.abs(player.x-bh.x)<6 && Math.abs(player.y-bh.y)<7){ onDeath('BOSS'); return; }
    }
shots = shots.filter(s=>!s.dead);
    bossShots = bossShots.filter(h=>!h.dead);
    enemyBullets = enemyBullets.filter(b=>!b.dead);
    shooters = shooters.filter(e=>!e.dead);
    chargers = chargers.filter(e=>!e.dead);

  hazards = hazards.filter(h=>!h.dead);

  if (boss && boss.dead){
    ctx.fillStyle=COL.Y; ctx.fillText('RAMPAGE KILLING SPREE!!', 100, 40);
    if (msgTimer--<=0){ nextAfterBoss(); return; }
  }

  if (boss) boss.draw();
  hazards.forEach(h=>h.draw());
  shooters.forEach(e=>e.draw());
  chargers.forEach(e=>e.draw());
  enemyBullets.forEach(b=>b.draw());
    crabs.forEach(c=>c.draw());
    spaceBombs.forEach(b=>b.draw());
    spaceships.forEach(s=>s.draw());
    bossShots.forEach(h=>h.draw());
  shots.forEach(s=>s.draw());
  player.draw();

  // Life bar
  if (boss){
    const pct = Math.max(0, Math.min(1, boss.hp / BOSS_MAX_HP));
    const barW = W-40, barH = 6, bx=20, by=10;
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(bx-1, by-1, barW+2, barH+2);
    ctx.fillStyle=COL.INK; ctx.fillRect(bx, by, barW, barH);
    ctx.fillStyle=COL.G2; ctx.fillRect(bx, by, (barW*pct)|0, barH);
  }

  // Screen flash + explosion particles
  if (screenFlash>0){ ctx.fillStyle='rgba(255,255,255,'+(screenFlash/16).toFixed(2)+')'; ctx.fillRect(0,0,W,H); screenFlash--; }
  bossBooms.forEach(b=>b.update()); bossBooms = bossBooms.filter(b=>b.life>0);
  bossBooms.forEach(b=>b.draw());
}


  function spawnHazard(slowBoss){
    const minDist = 60;
    let x,y,tries=0;
    do{
      const side = (Math.random()*4)|0;
      if (side===0){ x=0; y=Math.random()*(H-12); }
      if (side===1){ x=W-1; y=Math.random()*(H-12); }
      if (side===2){ x=Math.random()*W; y=0; }
      if (side===3){ x=Math.random()*W; y=H-12; }
      tries++;
    } while (tries<30 && Math.hypot((player.x-x),(player.y-y)) < minDist);

    let base = ((slowBoss?0.55:0.60) + 0.024*(level-1)) * diffMul();
    if (active('slow')) base *= 0.6;
    const dx = player.x - x, dy = player.y - y, L = Math.max(1, Math.hypot(dx,dy));
    hazards.push(new Hazard(x,y, dx/L*base, dy/L*base));
  }

  function drawEnding(){
    ctx.fillStyle=COL.INK; ctx.font='bold 10px monospace'; ctx.fillText('You have mastered Moon Master!', 38, 66);
    ctx.font='8px monospace';
    ctx.fillText('YOU ARE THE MOON MASTER!', 76, 84);
    ctx.fillText('Press N for NEW GAME+  •  Enter for Title', 40, 110);
  }

  function startNewGamePlus(){
  ngPlus++;
  // carry over score & hi; reset level and state; clear effects and entities
  level = 1;
  for (const k in effects) effects[k]=0;
  player = new Player();
  enemies=[]; shooters=[]; chargers=[]; enemyBullets=[]; hazards=[]; boss=null; bossShots=[]; spaceships=[]; spaceBombs=[]; crabs=[]; shots=[];
  state='PLAY';
  startLevel();
}

  function loop(){
    requestAnimationFrame(loop);
  try { if (typeof state!=='undefined' && state==='CREDITS') { drawCredits(); if (typeof hud==='function') hud(); return; } } catch(_) {}
drawMoon();
    if (state==='TITLE') { drawTitle(); hud(); return; }
    if (state==='LEVEL_SELECT') { drawLevelSelect(); hud(); return; }
    if (state==='SHOP') { drawShop(); hud(); return; }
    if (state==='CONTINUE') { drawContinue(); hud(); return; }
    if (state==='PLAY') { drawPlay(); hud(); return; }
    if (state==='BOSS') { drawBoss(); hud(); return; }
    if (state==='ENDING') { if (keys.has('n')||keys.has('N')){ startNewGamePlus(); return; } drawEnding(); hud(); return; }
  }

  document.getElementById('reset').onclick=()=>{ updateHi(); score=0; state='TITLE'; level=1; for (const k in effects) effects[k]=0; startLevel(); };
  document.getElementById('full').onclick=()=>{ if (document.fullscreenElement) document.exitFullscreen(); else cvs.requestFullscreen().catch(()=>{}); };

  // init
  state='TITLE'; startLevel(); loop();
})();

// --- Secret Credits (hold K on title) ---
(function(){
  try {
    if (typeof window.__creditsHoldInstalled === 'boolean' && window.__creditsHoldInstalled) return;
    window.__creditsHoldInstalled = true;
  } catch(_) {}

  try { window.__creditsHeld = false; } catch(_) {}

  window.addEventListener('keydown', function(e){
    try {
      if ((e.key==='k' || e.key==='K') && typeof state!=='undefined' && state==='TITLE') {
        if (!window.__creditsHeld) {
          window.__creditsHeld = true;
          state = 'CREDITS';
        }
      }
    } catch(_){}
  });

  window.addEventListener('keyup', function(e){
    try {
      if (e.key==='k' || e.key==='K') {
        window.__creditsHeld = false;
        if (typeof state!=='undefined' && state==='CREDITS') {
          state = 'TITLE';
        }
      }
    } catch(_){}
  });
})();
// --- end Secret Credits listeners ---


function drawCredits(){
  try { ctx.fillStyle='rgba(0,0,0,0.75)'; ctx.fillRect(0,0,W,H); } catch(_){}
  var cx = (typeof W!=='undefined'? W : 320)/2;
  var cy = (typeof H!=='undefined'? H : 200)/2;

  try {
    var prevAlign = ctx.textAlign;
    ctx.textAlign = 'center';

    ctx.fillStyle = (COL && COL.INK) ? COL.INK : '#ffffff';
    ctx.font = 'bold 12px monospace';
    ctx.fillText('FOR KB', cx, cy - 30);

    ctx.font = '10px monospace';
    ctx.fillText('#1 in the Hood, G!', cx, cy - 10);
    ctx.fillText('Special Thanks to r/AquaJail', cx, cy + 10);

    ctx.fillStyle = (COL && COL.G3) ? COL.G3 : '#cccccc';
    ctx.font = '8px monospace';
    ctx.fillText('Press and hold K on title', cx, cy + 40);

    ctx.textAlign = prevAlign;
  } catch(_){}
}

</script>
</body>
</html>
