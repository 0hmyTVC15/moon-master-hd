<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moon Master ‚Äî fan spoof (web)</title>
  <style>
    :root {
      --bg: #000;
      --fg: #ffffff;
      --accent: #00ff66; /* neon green */
      --accent2: #ff00aa; /* magenta */
      --accent3: #00e7ff; /* cyan */
      --accent4: #ffff55; /* yellow */
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); display: grid; place-items: center; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #container { position: relative; }
    canvas { width: 768px; height: 576px; image-rendering: pixelated; image-rendering: crisp-edges; background: #000; border: 4px solid var(--fg); box-shadow: 0 0 0 8px rgba(255,255,255,0.08), 0 20px 60px rgba(0,0,0,0.8); border-radius: 8px; }
    #hint { position: absolute; left: 8px; right: 8px; bottom: 6px; font-size: 12px; opacity: .75; display: flex; justify-content: space-between; gap: 12px; align-items: center; pointer-events: none; }
    .btnbar { position: absolute; top: 8px; right: 8px; display: flex; gap: 8px; }
    .btn { pointer-events: auto; background: #111; border: 1px solid #333; padding: 6px 10px; font-size: 12px; border-radius: 6px; color: #ddd; cursor: pointer; }
    .btn:hover { filter: brightness(1.2); }
    a { color: var(--accent3); text-decoration: none; }

    /* Importer panel */
    #btnImp { position: absolute; top: 8px; left: 8px; }
    .panel { position: absolute; inset: auto auto 12px 12px; width: 320px; background: rgba(0,0,0,.92); border: 1px solid #333; border-radius: 10px; padding: 10px; box-shadow: 0 10px 40px rgba(0,0,0,.6); }
    .panel.hidden { display: none; }
    .panel h3 { margin: 0 0 8px 0; font-size: 14px; }
    .row { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; margin: 6px 0; }
    input[type=file] { width: 100%; font-size: 11px; }
    .sub { font-size: 11px; opacity: .7; }
    label.inline { display: flex; align-items: center; gap: 8px; margin: 6px 0; }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="game" width="256" height="192"></canvas>
    <div class="btnbar">
      <button class="btn" id="btnMute" title="M">üîá Mute</button>
      <button class="btn" id="btnReset" title="R">‚Üª Reset</button>
      <button class="btn" id="btnFull" title="F">‚õ∂ Fullscreen</button>
    </div>
    <button class="btn" id="btnImp" title="I">Assets (I)</button>

    <div id="importer" class="panel hidden">
      <h3>Asset Loader</h3>
      <div class="row"><label>Player PNG <span class="sub">(drawn ~10√ó12px)</span></label><input type="file" id="filePlayer" accept="image/*"></div>
      <div class="row"><label>Enemy PNG <span class="sub">(~8√ó8px)</span></label><input type="file" id="fileEnemy" accept="image/*"></div>
      <div class="row"><label>Boss PNG <span class="sub">(~60√ó30px)</span></label><input type="file" id="fileBoss" accept="image/*"></div>
      <div class="row"><label>Background Image</label><input type="file" id="fileBg" accept="image/*"></div>
      <label class="inline"><input type="checkbox" id="chkSolid"> Use near-black pixels in background as solid platforms</label>
      <div class="row"><label>Solid threshold <span class="sub">(0 = pure black)</span></label><input type="range" id="thr" min="0" max="128" value="48"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
        <button class="btn" id="btnCloseImp">Close</button>
      </div>
    </div>

    <div id="hint">
      <div>Controls: ‚Üê ‚Üí move ‚Ä¢ ‚Üë jump ‚Ä¢ X zap ‚Ä¢ Enter start ‚Ä¢ M mute ‚Ä¢ I assets</div>
      <div><small>Not affiliated with Adult Swim. Parody/fan work.</small></div>
    </div>
  </div>
  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });
    const W = canvas.width, H = canvas.height;

    // --- Palette
    const COL = { BG:'#000', INK:'#fff', G1:'#00ff66', G2:'#ff00aa', G3:'#00e7ff', Y:'#ffff55' };

    // --- Resize for integer scaling
    function fit(){ const scale = Math.max(1, Math.floor(Math.min(window.innerWidth/W, window.innerHeight/H))); canvas.style.width=(W*scale)+'px'; canvas.style.height=(H*scale)+'px'; }
    window.addEventListener('resize', fit); fit();

    // --- Inputs
    const keys = new Set();
    window.addEventListener('keydown', (e)=>{ if (['ArrowLeft','ArrowRight','ArrowUp','Space','x','X','Enter','m','M','f','F','r','R','i','I'].includes(e.key)) e.preventDefault(); keys.add(e.key);});
    window.addEventListener('keyup', (e)=> keys.delete(e.key));

    // --- Audio
    let audioOn=false, ac=null; function ensureAudio(){ if(!audioOn){ ac=new (window.AudioContext||window.webkitAudioContext)(); audioOn=true; document.getElementById('btnMute').textContent='üîä Sound'; } }
    function beep(freq=440,dur=0.08,type='square',vol=0.15){ if(!audioOn||!ac) return; const o=ac.createOscillator(), g=ac.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=vol; o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+dur); }

    // --- UI buttons
    document.getElementById('btnMute').onclick=()=>{ if(!audioOn){ensureAudio();return;} audioOn=false; try{ac.close();}catch{} ac=null; document.getElementById('btnMute').textContent='üîá Mute'; };
    document.getElementById('btnReset').onclick=()=>{ ensureAudio(); resetGame(); };
    document.getElementById('btnFull').onclick=()=>{ if(document.fullscreenElement) document.exitFullscreen(); else canvas.requestFullscreen().catch(()=>{}); };

    // --- Asset loader UI
    const imp = document.getElementById('importer');
    const btnImp = document.getElementById('btnImp');
    const btnCloseImp = document.getElementById('btnCloseImp');
    btnImp.onclick=()=>imp.classList.toggle('hidden');
    btnCloseImp.onclick=()=>imp.classList.add('hidden');
    window.addEventListener('keydown', (e)=>{ if(e.key==='i'||e.key==='I'){ imp.classList.toggle('hidden'); } });

    const assets = { player:null, enemy:null, boss:null, bg:null };
    const bgCanvas = document.createElement('canvas'); bgCanvas.width=W; bgCanvas.height=H; const bgCtx = bgCanvas.getContext('2d');
    let useSolid=false, threshold=48; let solidMask=null; // Uint8Array W*H where 1 = solid
    const chkSolid = document.getElementById('chkSolid');
    const thr = document.getElementById('thr');
    chkSolid.onchange = ()=>{ useSolid = chkSolid.checked; rebuildSolid(); };
    thr.oninput = ()=>{ threshold = +thr.value; rebuildSolid(); };

    function loadImageFromInput(input, setter){ input.addEventListener('change', ()=>{ const f=input.files&&input.files[0]; if(!f) return; const url=URL.createObjectURL(f); const img=new Image(); img.onload=()=>{ setter(img); URL.revokeObjectURL(url); }; img.src=url; }); }

    loadImageFromInput(document.getElementById('filePlayer'), (img)=> assets.player=img);
    loadImageFromInput(document.getElementById('fileEnemy'),  (img)=> assets.enemy=img);
    loadImageFromInput(document.getElementById('fileBoss'),   (img)=> assets.boss=img);
    loadImageFromInput(document.getElementById('fileBg'),     (img)=> { assets.bg=img; drawBgToCanvas(); rebuildSolid(); });

    function drawBgToCanvas(){ if(!assets.bg) return; // fit background image into W√óH while preserving aspect (contain)
      const iw=assets.bg.naturalWidth, ih=assets.bg.naturalHeight; const ar=iw/ih; const tr=W/H; let dw=W, dh=H; if(ar>tr){ dh = Math.round(W/ar); } else { dw = Math.round(H*ar); }
      bgCtx.fillStyle='#000'; bgCtx.fillRect(0,0,W,H);
      const dx=(W-dw)>>1, dy=(H-dh)>>1; bgCtx.drawImage(assets.bg, dx, dy, dw, dh);
    }

    function rebuildSolid(){ if(!assets.bg || !useSolid){ solidMask=null; return; }
      drawBgToCanvas(); const imgData = bgCtx.getImageData(0,0,W,H).data; solidMask = new Uint8Array(W*H);
      for(let i=0, p=0; i<imgData.length; i+=4, p++){
        const r=imgData[i], g=imgData[i+1], b=imgData[i+2], a=imgData[i+3];
        // consider near-black opaque-ish pixels as solid
        solidMask[p] = (a>16 && (r+g+b) <= threshold) ? 1 : 0;
      }
      // clear an area in the top-left for any HUD in the screenshot
      for(let y=0; y<24; y++){ for(let x=0; x<110; x++){ solidMask[y*W+x]=0; } }
    }

    function isSolidAt(x,y){ if(!solidMask) return y>=H-12; // default: flat ground near bottom
      if(x<0||x>=W||y<0||y>=H) return true; return solidMask[(y|0)*W + (x|0)]===1;
    }

    // --- Stars background (fallback)
    const stars = new Array(64).fill(0).map(()=>({x: Math.random()*W, y: Math.random()*H, z: Math.random()*1}));
    function drawStars(){ ctx.fillStyle=COL.BG; ctx.fillRect(0,0,W,H); for(const s of stars){ s.x -= 0.1 + s.z*0.3; if (s.x<0){ s.x+=W; s.y=Math.random()*H; s.z=Math.random(); } ctx.fillStyle = s.z>0.66?COL.G3:(s.z>0.33?COL.G2:COL.INK); ctx.fillRect(s.x|0, s.y|0, 1, 1);} }

    function drawBackground(){ if(assets.bg){ ctx.drawImage(bgCanvas,0,0); } else { drawStars(); } }

    // --- Physics & entities
    const GRAV = 0.25;

    function rectCollides(x,y,w,h){ // any solid under rect?
      for(let yy=y|0; yy<(y+h)|0; yy++){ for(let xx=x|0; xx<(x+w)|0; xx++){ if(isSolidAt(xx,yy)) return true; } }
      return false;
    }

    class Player {
      constructor(){ this.x=16; this.y=20; this.vx=0; this.vy=0; this.onGround=false; this.facing=1; this.cool=0; this.alive=true; this.w=8; this.h=10; }
      update(){
        const left = keys.has('ArrowLeft'); const right = keys.has('ArrowRight'); const jump = keys.has('ArrowUp'); const shoot = keys.has('x')||keys.has('X');
        if (left)  { this.vx=Math.max(this.vx-0.25,-1.2); this.facing=-1; }
        if (right) { this.vx=Math.min(this.vx+0.25, 1.2); this.facing=1; }
        if (!left && !right) this.vx *= 0.8;
        if (jump && this.onGround) { this.vy = -3.2; this.onGround=false; beep(220,0.06,'square',0.12); }
        if (shoot && this.cool<=0) { shots.push(new Shot(this.x+6*this.facing, this.y+this.h-6, this.facing)); this.cool=10; beep(880,0.05,'square',0.08);} if(this.cool>0) this.cool--;
        // Apply gravity
        this.vy += GRAV;
        // Horizontal step & collide
        this.x += this.vx; if (rectCollides(this.x, this.y, this.w, this.h)) { while(rectCollides(this.x, this.y, this.w, this.h)) this.x -= Math.sign(this.vx||1); this.vx=0; }
        // Vertical step & collide
        this.y += this.vy; if (rectCollides(this.x, this.y, this.w, this.h)) { const dir=Math.sign(this.vy||1); while(rectCollides(this.x, this.y, this.w, this.h)) this.y -= dir; if (dir>0){ this.onGround=true; } this.vy=0; } else { this.onGround=false; }
        // Bounds
        if (this.x<1){ this.x=1; this.vx=0; } if(this.x>W-this.w-1){ this.x=W-this.w-1; this.vx=0; }
      }
      draw(){
        if (assets.player) { ctx.drawImage(assets.player, this.x|0, (this.y|0)-2, 10, 12); return; }
        ctx.fillStyle = COL.G1; ctx.fillRect(this.x|0, (this.y-10)|0, 8, 10);
        ctx.fillStyle = COL.G3; ctx.fillRect((this.x+2)|0, (this.y-8)|0, 4, 3);
        ctx.fillStyle = COL.G2; ctx.fillRect(this.x|0, this.y|0, 3, 2); ctx.fillRect((this.x+5)|0, this.y|0, 3, 2);
      }
    }

    class Shot { constructor(x,y,dir){ this.x=x; this.y=y; this.vx=dir*2.2; this.dead=false; }
      update(){ this.x += this.vx; if (this.x<0||this.x>W||isSolidAt(this.x|0, this.y|0)) this.dead=true; }
      draw(){ ctx.fillStyle = COL.Y; ctx.fillRect(this.x|0, this.y|0, 3, 1); }
    }

    class Enemy { constructor(x){ this.x=x; this.y=10; this.vx=0.5*(Math.random()<0.5?-1:1); this.dead=false; this.w=8; this.h=8; }
      update(){
        // simple gravity + collisions like player, but with tiny AI: flip when hitting wall or edge
        this.vy = (this.vy||0) + GRAV; this.x += this.vx; if (rectCollides(this.x, this.y, this.w, this.h)) { while(rectCollides(this.x, this.y, this.w, this.h)) this.x -= Math.sign(this.vx); this.vx*=-1; }
        this.y += this.vy; if (rectCollides(this.x, this.y, this.w, this.h)) { while(rectCollides(this.x, this.y, this.w, this.h)) this.y -= Math.sign(this.vy); this.vy=0; }
        // turn around at edges
        const aheadX = this.x + (this.vx>0?this.w+1:-1); const footY = this.y + this.h + 1; if (!isSolidAt(aheadX|0, footY|0)) this.vx *= -1;
      }
      draw(){ if (assets.enemy) { ctx.drawImage(assets.enemy, (this.x|0), (this.y|0)-2, 8, 10); return; } ctx.fillStyle = COL.G2; ctx.fillRect((this.x|0), (this.y|0), 8, 8); }
    }

    class Gorgotron { constructor(){ this.x=W-88; this.y=20; this.hp=1; this.dead=false; this.tick=0; this.w=60; this.h=30; }
      update(){ this.tick++; if (this.tick%120===0) beep(110,0.1,'square',0.2); // settle onto floor if background has platforms
        // try to stand on floor
        this.vy = (this.vy||0) + GRAV; this.y += this.vy; if (rectCollides(this.x, this.y, this.w, this.h)) { while(rectCollides(this.x, this.y, this.w, this.h)) this.y -= Math.sign(this.vy); this.vy=0; }
      }
      hit(){ if (!this.dead) { this.hp--; if (this.hp<=0) { this.dead=true; for (let i=0;i<10;i++) particles.push(new Particle(this.x+Math.random()*this.w, this.y+Math.random()*this.h)); beep(60,0.25,'sawtooth',0.2);} } }
      draw(){ if (this.dead) return; if (assets.boss) { ctx.drawImage(assets.boss, this.x|0, this.y|0, this.w, this.h); return; } ctx.fillStyle = COL.G2; ctx.fillRect(this.x|0, this.y|0, this.w, this.h); ctx.fillStyle=COL.G3; ctx.fillRect((this.x+20)|0, (this.y+6)|0, 20, 6); }
    }

    class Particle { constructor(x,y){ this.x=x; this.y=y; this.vx=(Math.random()*2-1); this.vy=(Math.random()*-1.5-0.5); this.t=60; }
      update(){ this.t--; this.x+=this.vx; this.y+=this.vy; this.vy+=0.05; }
      draw(){ if (this.t<=0) return; ctx.fillStyle = COL.Y; ctx.fillRect(this.x|0, this.y|0, 1,1); }
    }

    let player, shots, enemies, boss, particles;

    // --- State
    let state='TITLE'; let level=1; let goalX=W-24; let msgTimer=0;

    function resetLevel(){
      player = new Player(); player.y = 8; // will drop onto first platform/ground
      shots = []; enemies = level<5 ? new Array(Math.max(0, level-1)).fill(0).map((_,i)=> new Enemy(40 + i*40)) : [];
      boss = (state==='BOSS') ? new Gorgotron() : null; particles = []; msgTimer = 60;
    }
    function resetGame(){ level=1; state='TITLE'; resetLevel(); }

    function drawUIBar(){ ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,0,W,12); ctx.fillStyle=COL.INK; ctx.fillText(`LEVEL ${level<=4?level:'BOSS'}  SCORE ${(level-1)*100}`, 4, 9); }

    function loop(){ requestAnimationFrame(loop); drawBackground(); if (state==='TITLE') return drawTitle(); if (state==='SHOP') return drawShop(); if (state==='ENDING') return drawEnding(); if (state==='PLAY') return drawPlay(); if (state==='BOSS') return drawBoss(); }

    function drawPlay(){ drawUIBar();
      // goal pillar (walk into it to win)
      ctx.fillStyle = COL.G3; ctx.fillRect(goalX, 12, 6, H-24); // tall beacon so it isn't hidden by background
      ctx.fillStyle = COL.Y; ctx.fillRect(goalX-4, 12, 10, 3);
      player.update(); if (player.x>goalX-1) { level++; if (level<=4) { ensureAudio(); beep(520,0.08); beep(660,0.08); state='PLAY'; resetLevel(); } else { state='SHOP'; resetLevel(); } return; }
      enemies.forEach(e=>e.update()); shots.forEach(s=>s.update());
      // shot-enemy collisions
      shots.forEach(s=>{ enemies.forEach(e=>{ if (!e.dead && Math.abs(s.x - (e.x+e.w/2)) < 6 && Math.abs(s.y - (e.y+e.h/2)) < 6) { e.dead=true; s.dead=true; particles.push(new Particle(e.x, e.y)); beep(300,0.06); } }); });
      enemies = enemies.filter(e=>!e.dead); shots = shots.filter(s=>!s.dead);
      enemies.forEach(e=>e.draw()); shots.forEach(s=>s.draw()); player.draw(); particles.forEach(p=>p.update()); particles.forEach(p=>p.draw()); particles = particles.filter(p=>p.t>0);
      if (msgTimer>0) { msgTimer--; ctx.fillStyle = COL.INK; ctx.fillText('WALK RIGHT TO WIN', 80, 20); }
    }

    function drawBoss(){ drawUIBar(); ctx.fillStyle = COL.INK; ctx.fillText('FINAL BOSS: THE GORGOTRON', 62, 20);
      player.update(); if (!boss) boss = new Gorgotron(); boss.update();
      shots.forEach(s=>{ s.update(); if (!boss.dead && s.x>boss.x && s.x<boss.x+boss.w && s.y>boss.y && s.y<boss.y+boss.h) { boss.hit(); s.dead=true; } }); shots = shots.filter(s=>!s.dead);
      boss.draw(); shots.forEach(s=>s.draw()); player.draw(); particles.forEach(p=>p.update()); particles.forEach(p=>p.draw()); particles = particles.filter(p=>p.t>0);
      if (boss.dead) { ctx.fillStyle = COL.Y; ctx.fillText('YOU WIN. (OF COURSE.)', 86, 40); if (msgTimer--<=0) { state='ENDING'; } }
    }

    function drawTitle(){ ctx.fillStyle = COL.INK; ctx.font = 'bold 12px monospace'; ctx.fillText('MOON MASTER', 84, 50); ctx.font = '8px monospace'; ctx.fillStyle = COL.G1; ctx.fillText('A deliberately easy, scammy fan-spoof of an 80s-styled game.', 20, 68); ctx.fillStyle = COL.G3; ctx.fillText('Press Enter or Click to Begin', 60, 86); ctx.fillStyle = COL.INK; ctx.fillText('Controls: ‚Üê ‚Üí move  ‚Üë jump  X zap  (M mute, F fullscreen, R reset, I assets)', 8, 104); ctx.fillStyle = COL.G2; ctx.fillText('Beat Level 4 to become the "Moon Master" and unlock the Shop.', 18, 122);
      // goal beacon demo
      ctx.fillStyle = COL.G2; ctx.fillRect(W-28, 12, 6, H-24); ctx.fillStyle = COL.Y; ctx.fillRect(W-32, 12, 10, 3); const demo = new Player(); demo.x = 30; demo.draw(); if (keys.has('Enter')) { ensureAudio(); state='PLAY'; resetLevel(); } }

    // Shop screen
    const shopItems = [ {name:'Moon Master Foam Finger', price: '19.99'}, {name:'Gorgotron Repellent (Do Not Ingest)', price: '49.99'}, {name:'Official Helmet (Cardboard)', price: '89.99'}, {name:'Certificate of Mastery (Printed)', price: '14.99'}, {name:'Premium Certificate (Gold-ish)', price: '29.99'}, {name:'Mystery Box (Probably Air)', price: '999.99'}, ];
    let shopFlash=0; let lastClickMsg='';
    canvas.addEventListener('click', (e)=>{ const rect = canvas.getBoundingClientRect(); const scale = parseInt(canvas.style.width) / W || 1; const mx = (e.clientX - rect.left) / scale; const my = (e.clientY - rect.top) / scale; if (state==='TITLE') { ensureAudio(); state='PLAY'; resetLevel(); return; } if (state==='SHOP') { if (mx>20 && mx<120 && my>H-30 && my<H-16) { state='BOSS'; resetLevel(); return; } const startY = 50; shopItems.forEach((it, idx)=>{ const y = startY + idx*18; if (mx>16 && mx<W-16 && my>y-8 && my<y+8) { ensureAudio(); beep(660,0.05,'square',0.15); shopFlash=6; lastClickMsg = `Order placed: ${it.name}. We accept checks only.`; } }); } });

    function drawShop(){ ctx.fillStyle = COL.INK; ctx.font = 'bold 10px monospace'; ctx.fillText('CONGRATULATIONS! YOU ARE THE MOON MASTER.', 18, 24); ctx.font = '8px monospace'; ctx.fillStyle = COL.G3; ctx.fillText('As Moon Master, you are now eligible for EXCLUSIVE MERCH!', 16, 36); const startY = 50; shopItems.forEach((it, idx)=>{ const y = startY + idx*18; if (shopFlash>0) ctx.fillStyle = (shopFlash%2?COL.Y:COL.INK); else ctx.fillStyle=COL.INK; ctx.fillText(`${it.name}`, 16, y); ctx.fillStyle = COL.G2; ctx.fillText(`$${it.price}  [CLICK TO BUY]`, 170, y); }); if (shopFlash>0) shopFlash--; ctx.fillStyle = COL.G2; ctx.fillRect(20, H-30, 100, 14); ctx.fillStyle = COL.BG; ctx.fillText('CONTINUE ‚Üí', 40, H-19); ctx.fillStyle = COL.G1; ctx.fillText(lastClickMsg || 'Note: All sales are non-refundable and probably non-existent.', 12, H-6); if (keys.has('Enter')) { state='BOSS'; resetLevel(); } }

    function drawEnding(){ ctx.fillStyle = COL.INK; ctx.font = 'bold 10px monospace'; ctx.fillText('THE GORGOTRON HAS BEEN DEFEATED.', 44, 48); ctx.font = '8px monospace'; ctx.fillStyle = COL.G3; ctx.fillText('The Moon is safe.*', 96, 64); ctx.fillStyle = COL.G2; ctx.fillText('*Probably. Results may vary upon return to lunar surface.', 20, 78); ctx.fillStyle = COL.INK; ctx.fillText('Press R to reset or F for fullscreen.', 62, 96); if (keys.has('r') || keys.has('R')) resetGame(); }

    // Boot
    ctx.imageSmoothingEnabled=false; ctx.font='8px monospace'; resetGame(); requestAnimationFrame(loop);

    window.addEventListener('keydown', (e)=>{ if (e.key==='Enter') ensureAudio(); if (e.key==='M'||e.key==='m'){ if(!audioOn) ensureAudio(); else { audioOn=false; try{ac.close();}catch{}; ac=null; document.getElementById('btnMute').textContent='üîá Mute'; } } if (e.key==='F'||e.key==='f'){ if(document.fullscreenElement) document.exitFullscreen(); else canvas.requestFullscreen().catch(()=>{}); } if (e.key==='R'||e.key==='r'){ ensureAudio(); resetGame(); } });
  })();
  </script>
</body>
</html>